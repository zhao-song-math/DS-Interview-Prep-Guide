# 15. 3Sum

[Leetcode ↗](https://leetcode.com/problems/3sum/description/?envType=problem-list-v2&envId=xi4ci4ig) | [Neetcode ↗](https://neetcode.io/problems/three-integer-sum?list=blind75)

<font color="#FF8F00">Medium</font> | <span style="background-color:#E3F2FD; color:#1565C0; padding:3px 8px; border-radius:12px; font-size:12px; font-weight:bold;">Array</span> <span style="background-color:#FFFDE7; color:#F9A825; padding:3px 8px; border-radius:12px; font-size:12px; font-weight:bold;">Two Pointers</span> <span style="background-color:#FFEBEE; color:#B71C1C; padding:3px 8px; border-radius:12px; font-size:12px; font-weight:bold;">Sorting</span>

## Description
Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

    Input: nums = [-1,0,1,2,-1,-4]
    Output: [[-1,-1,2],[-1,0,1]]
    Explanation: 
    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
    The distinct triplets are [-1,0,1] and [-1,-1,2].
    Notice that the order of the output and the order of the triplets does not matter.

**Example 2:**

    Input: nums = [0,1,1]
    Output: []
    Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

    Input: nums = [0,0,0]
    Output: [[0,0,0]]
    Explanation: The only possible triplet sums up to 0.

**Constraints:**
* `3 <= nums.length <= 3000`
* `-10^5 <= nums[i] <= 10^5`

---


## 题目解析


### 🟢 Solution 1

此解使用 [Two Pointers](Two_Pointers.md) 算法。考虑三个 indices `i, j, k`, 先固定 `i`，`j` 和 `k` 作为一左一右的反向双指针。当满足`nums[i] + nums[j] + nums[k] = 0`时，将`[nums[i],nums[j],nums[k]]`添加至return list。

```
[-1,0,1,2,-1,-4]
  i j        k

nums[i] + nums[j] + nums[k] = -5
```

首先我们需要给list排序，这样做有两点好处:

* 关于`i`：当`[-1,0,1]`被加入return list之后，`i`向后移，新的`[nums[i],nums[j],nums[k]]`组合又满足`nums[i] + nums[j] + nums[k] = 0`，与之前加入return list重复。由于`nums`已经被排好序，我们只要通过判断`num[i] == nums[i-1]`来确定`nums[i]`是否重复出现，如果重复那么`[nums[i],nums[j],nums[k]]`组合必然重复，这样就可以continue循环，让`i`向后移至下一个位置。
  
```
[-4,-1,-1,0,1,2]
     i    j k

nums[i] + nums[j] + nums[k] = 0
-------
[-4,-1,-1,0,1,2]
        i j k

nums[i] + nums[j] + nums[k] = 0
```

* 关于`j,k`：当不满足`nums[i] + nums[j] + nums[k] = 0`时，如何移动`j,k`？可以通过比较`nums[i] + nums[j] + nums[k]`是否大于零来确定，当大于零时，`k`往左移；当小于零时，`j`往右移。

**代码如下：**

```Python
class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
      res = []
      nums.sort()

      for i in range(len(nums)-2):

      #这个条件不加也可以，但是加了可以提高速度
          if nums[i] > 0:
              break
              
          if i > 0 and nums[i] == nums[i-1]:
              continue

          j = i+1
          k = len(nums)-1

          while j<k:
              if nums[i] + nums[j] + nums[k] < 0:
                  j += 1
              elif nums[i] + nums[j] + nums[k] > 0:
                  k -= 1
              else: # nums[i] + nums[j] + nums[k] = 0
                  res.append([nums[i],nums[j],nums[k]])

                  j += 1

                  while j<k and nums[j] == nums[j-1]:
                      j += 1

      return res
```

* Time complexity: $\mathcal{O}(n)$ 
    $\mathcal{O}(n\log n) + \mathcal{O}(n)$, `list.sort()` + 循环
* Space complexity: $\mathcal{O}(n)$ 
  In python, sorting algorithm use Timsort which uses O(n) space.

---

This question is similar to **167. Two Sum II - Input Array Is Sorted** question.

## Backlinks
- [Leetcode 笔记目录](Leetcode笔记目录.md)
- [Two Pointers](Two_Pointers.md)